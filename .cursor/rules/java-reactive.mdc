---
description: Java 25 + Spring Boot 4 virtual-thread-first development guidelines for the Kashy project
globs: ["**/*.java"]
alwaysApply: true
---

# Java 25 + Spring Boot 4 Virtual-Thread-First Development Rules

## Tone & Goals

- Write small, composable, and intention-revealing functions
- Prefer immutability and clarity over cleverness
- Only include comments/Javadoc when they add real value (public APIs, non-obvious logic, concurrency, security, or performance implications)

## Language & Features (Java 25)

- Use **records** for immutable data carriers; validate in canonical constructors if needed
- Model closed domains with **sealed hierarchies**
- Prefer **pattern matching** (`switch`/`instanceof`) for concise branching
- Use **string templates** where available; otherwise `String.format`
- Wrap **Foreign Function & Memory (FFM) API** behind small, well-documented adapters when required

## Spring Boot 4 Conventions

Spring Boot 4 builds on **Spring Framework 7**, providing modularization, JSpecify null-safety, and first-class Java 25 support.

- Use **Spring MVC (Servlet stack)** as the default web stack (not Spring WebFlux)
- Prefer **functional endpoint routing** (`RouterFunction`) for simple APIs; use `@RestController` for complex ones
- Configure with `application.yaml`; use **Spring Boot's type-safe configuration** (`@ConfigurationProperties` with records)
- Use **constructor injection** exclusively; avoid `@Autowired` on fields
- Leverage **Spring Boot's auto-configuration**; override only when necessary
- For data access, prefer **Spring Data JDBC/JPA** (blocking drivers are expected)
- Use **Spring Security (Servlet)** configuration (not reactive security)
- Prefer **declarative HTTP clients** (`@HttpExchange` interfaces) over manual client setup
- Outbound HTTP:
  - Prefer `RestClient` / `@HttpExchange` for straightforward calls
  - Use `WebClient` only when you need streaming APIs or advanced HTTP features

## Virtual Threads (Default Concurrency Model)

- Use **virtual threads** as the default request-execution model.
- Enable virtual threads via configuration:
  - `spring.threads.virtual.enabled=true`
- Write normal blocking code for IO (DB/HTTP/files) without reactive wrappers.
- Do not create custom platform-thread pools unless you have a proven need.

## API-First Development

- **Design the contract first**: define OpenAPI/Swagger specifications before implementation
- Generate server stubs and DTOs from the OpenAPI spec; do not hand-write API models
- Keep specs in `src/main/resources/openapi/` or a dedicated `api/` module
- Use **semantic versioning** for API changes; leverage Spring Boot 4's API versioning support
- Validate requests/responses against the contract in tests
- Document breaking vs non-breaking changes; maintain changelog per API version
- Consumer-driven contracts: consider **Spring Cloud Contract** or **Pact** for integration testing

## Functional Style (Imperative IO, Functional Core)

- Strive for **pure functions**: avoid side effects and shared mutable state
- Use immutable collections and defensive copies. No public mutators.
- Favor **functional composition** in the domain layer:
  - Express transformations with `map`, `filter`, `collect`, `reduce`
  - Keep IO at the boundaries (controllers, repositories, gateways)
- Use `Optional` only as a **return type** to represent absence; never for fields, parameters, or collections
- Error strategy:
  - For exceptional states, throw domain exceptions with precise messages
  - For recoverable cases, prefer explicit result types (sealed hierarchies) over exceptions
  - Map low-level exceptions to domain-level ones at service boundaries

## Concurrency & Performance

- **Virtual-thread-first**: blocking IO is allowed and expected; keep it at the boundaries.
- Prefer **structured concurrency** for fan-out / parallel IO:
  - Use `StructuredTaskScope` for parallel calls with clear failure/timeout semantics
  - Avoid ad-hoc thread creation; never use `new Thread(...)`
- Bound concurrency intentionally:
  - DB connection pools and HTTP connection pools are the real limitersâ€”size and timeouts matter
  - Do not assume virtual threads remove backpressure needs; enforce limits with bulkheads/timeouts
- Avoid pinning:
  - Minimize `synchronized` blocks and long-held locks
  - Avoid blocking while holding locks
- Measure before optimizing; document proven hotspots and chosen remedies

## API Design & Error Handling

- Public APIs must document:
  - Preconditions/postconditions
  - Threading/immutability guarantees
  - Nullability and error semantics
- Fail fast with precise messages; no silent catch-and-ignore
- Translate low-level exceptions to domain-level ones at service boundaries
- Keep DTOs small and stable (prefer records). Don't leak internals

## Logging

- Use SLF4J parameterized logging; avoid string concatenation
- Levels:
  - **INFO**: business milestones
  - **DEBUG**: flow details
  - **WARN**: recoverable anomalies
  - **ERROR**: failures needing attention
- Never log secrets or PII; apply redaction utilities

## Testing

- Use **JUnit 5** with parameterized tests where valuable
- Name tests clearly using Given/When/Then pattern
- Prefer:
  - `MockMvc` for MVC slice tests
  - `@SpringBootTest` for integration tests where necessary
- Test observable behavior, not internals. Avoid fragile timing-based tests
- Add property-based tests when they improve confidence

## Project Conventions

- Organize packages by **domain/module**; keep internals `package-private` where possible
- Standard Java naming/formatting; one public top-level type per file; small classes and methods
- Prefer the standard library and Spring ecosystem
- Add dependencies only with a clear, documented payoff and wrap behind interfaces
- Do not use FQN; include imports for new references in classes

## Comments & Javadoc (Keep It Lean)

- Javadoc only for:
  - Public APIs and SPIs
  - Non-trivial algorithms
  - Concurrency or performance-critical sections
- Inline comments explain **why**, not **what**

## Non-Goals

- No excessive annotations, builders, or boilerplate where a `record` suffices
- No premature abstraction; prefer straightforward solutions with strong names
- No reactive-first constraints (no requirement for `Mono`/`Flux`, backpressure operators, or reactive drivers)

## Definition of Done

- Compiles on **Java 25** with **Spring Boot 4**
- Follows this rule set (immutability, functional-first, virtual-thread-first concurrency)
- Clear, minimal documentation where it matters
- Tests cover critical paths and contracts
