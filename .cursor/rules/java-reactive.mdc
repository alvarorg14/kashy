---
description: Java 25 + Spring Boot 4 reactive-first development guidelines for the Kashy project
globs: ["**/*.java"]
alwaysApply: true
---

# Java 25 + Spring Boot 4 Reactive Development Rules

## Tone & Goals

- Write small, composable, and intention-revealing functions
- Prefer immutability and clarity over cleverness
- Only include comments/Javadoc when they add real value (public APIs, non-obvious logic, concurrency, security, or performance implications)

## Language & Features (Java 25)

- Use **records** for immutable data carriers; validate in canonical constructors if needed
- Model closed domains with **sealed hierarchies**
- Prefer **pattern matching** (`switch`/`instanceof`) for concise branching
- Use **string templates** where available; otherwise `String.format`
- Wrap **Foreign Function & Memory (FFM) API** behind small, well-documented adapters when required

## Spring Boot 4 Conventions

Spring Boot 4 builds on **Spring Framework 7**, providing modularization, JSpecify null-safety, and first-class Java 25 support.

- Use **Spring WebFlux** as the default web stack (not Spring MVC)
- Prefer **functional endpoint routing** (`RouterFunction`) for simple APIs; use `@RestController` for complex ones
- Configure with `application.yaml`; use **Spring Boot's type-safe configuration** (`@ConfigurationProperties` with records)
- Use **constructor injection** exclusively; avoid `@Autowired` on fields
- Leverage **Spring Boot's auto-configuration**; override only when necessary
- For data access, prefer **Spring Data R2DBC** or reactive MongoDB drivers
- Use **Spring Security's reactive support** (`@EnableWebFluxSecurity`)
- Prefer **declarative HTTP clients** (`@HttpExchange` interfaces) over manual `WebClient` setup

## API-First Development

- **Design the contract first**: define OpenAPI/Swagger specifications before implementation
- Generate server stubs and DTOs from the OpenAPI spec; do not hand-write API models
- Keep specs in `src/main/resources/openapi/` or a dedicated `api/` module
- Use **semantic versioning** for API changes; leverage Spring Boot 4's API versioning support
- Validate requests/responses against the contract in tests
- Document breaking vs non-breaking changes; maintain changelog per API version
- Consumer-driven contracts: consider **Spring Cloud Contract** or **Pact** for integration testing

## Functional & Reactive Style

- Strive for **pure functions**: avoid side effects and shared mutable state
- Use immutable collections and defensive copies. No public mutators
- Favor **reactive programming** (Project Reactor / WebFlux):
  - Compose with `Mono` and `Flux` instead of blocking APIs
  - Use operators (`map`, `flatMap`, `filter`, etc.) to express transformations
  - Ensure pipelines remain short and intention-revealing
- Use `Optional` only as a **return type** to represent absence; never for fields, parameters, or collections
- Error strategy:
  - For exceptional states, signal via reactive error channels (`Mono.error` / `Flux.error`)
  - For recoverable cases, prefer explicit result types or fallback operators

## Concurrency & Performance

- **Reactive-first**: do not block threads. Delegate all IO to reactive drivers (e.g., R2DBC, reactive Mongo)
- Avoid mixing reactive and imperative concurrency unless strictly necessary
- Use **Schedulers** for controlled parallelism; clearly mark boundaries where you switch execution contexts
- Ensure backpressure is respected; avoid unbounded buffering
- Minimize shared state; if unavoidable, encapsulate with clear synchronization or concurrency-safe structures
- Measure before optimizing; document proven hotspots and chosen remedies

## API Design & Error Handling

- Public APIs must document:
  - Preconditions/postconditions
  - Threading/immutability guarantees
  - Nullability and error semantics
- Fail fast with precise messages; no silent catch-and-ignore
- Map low-level exceptions to domain-level ones at reactive boundaries
- Keep DTOs small and stable (prefer records). Don't leak internals

## Logging

- Use SLF4J parameterized logging; avoid string concatenation
- Levels:
  - **INFO**: business milestones
  - **DEBUG**: flow details
  - **WARN**: recoverable anomalies
  - **ERROR**: failures needing attention
- Never log secrets or PII; apply redaction utilities

## Testing

- Use **JUnit 5** with parameterized tests where valuable
- Name tests clearly using Given/When/Then pattern
- For reactive flows, test with **StepVerifier** or equivalent
- Test observable behavior, not internals. Avoid fragile timing-based tests
- Add property-based tests when they improve confidence

## Project Conventions

- Organize packages by **domain/module**; keep internals `package-private` where possible
- Standard Java naming/formatting; one public top-level type per file; small classes and methods
- Prefer the standard library and reactive ecosystem
- Add dependencies only with a clear, documented payoff and wrap behind interfaces
- Do not use FQN; include imports for new references in classes

## Comments & Javadoc (Keep It Lean)

- Javadoc only for:
  - Public APIs and SPIs
  - Non-trivial algorithms
  - Concurrency or performance-critical sections
- Inline comments explain **why**, not **what**

## Non-Goals

- No excessive annotations, builders, or boilerplate where a `record` suffices
- No premature abstraction; prefer straightforward solutions with strong names
- No mixing blocking IO with reactive flows

## Definition of Done

- Compiles on **Java 25** with **Spring Boot 4**
- Follows this rule set (immutability, functional-first, reactive-first concurrency)
- Clear, minimal documentation where it matters
- Tests cover critical reactive paths and contracts
